// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core.Pipeline;
using Microsoft.Marketplace.Metering.Models;

namespace Microsoft.Marketplace.Metering
{
    /// <summary> The Metering service client. </summary>
    public partial class MeteringOperations
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal MeteringRestClient RestClient { get; }
        /// <summary> Initializes a new instance of MeteringOperations for mocking. </summary>
        protected MeteringOperations()
        {
        }
        /// <summary> Initializes a new instance of MeteringOperations. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal MeteringOperations(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null, string apiVersion = "2018-08-31")
        {
            RestClient = new MeteringRestClient(clientDiagnostics, pipeline, endpoint, apiVersion);
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        /// <summary> Posts a single usage event to the marketplace metering service API. </summary>
        /// <param name="body"> The UsageEvent to use. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<UsageEventOkResponse>> PostUsageEventAsync(UsageEvent body, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.PostUsageEvent");
            scope.Start();
            try
            {
                return await RestClient.PostUsageEventAsync(body, requestId, correlationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Posts a single usage event to the marketplace metering service API. </summary>
        /// <param name="body"> The UsageEvent to use. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<UsageEventOkResponse> PostUsageEvent(UsageEvent body, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.PostUsageEvent");
            scope.Start();
            try
            {
                return RestClient.PostUsageEvent(body, requestId, correlationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The batch usage event API allows you to emit usage events for more than one purchased entity at once. The batch usage event request references the metering services dimension defined by the publisher when publishing the offer. </summary>
        /// <param name="body"> The BatchUsageEvent to use. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<BatchUsageEventOkResponse>> PostBatchUsageEventAsync(BatchUsageEvent body, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.PostBatchUsageEvent");
            scope.Start();
            try
            {
                return await RestClient.PostBatchUsageEventAsync(body, requestId, correlationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The batch usage event API allows you to emit usage events for more than one purchased entity at once. The batch usage event request references the metering services dimension defined by the publisher when publishing the offer. </summary>
        /// <param name="body"> The BatchUsageEvent to use. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<BatchUsageEventOkResponse> PostBatchUsageEvent(BatchUsageEvent body, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.PostBatchUsageEvent");
            scope.Start();
            try
            {
                return RestClient.PostBatchUsageEvent(body, requestId, correlationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can call the usage events API to get the list of usage events. </summary>
        /// <param name="usageStartDate"> DateTime in ISO8601 format. For example, 2020-12-03T15:00 or 2020-12-03. </param>
        /// <param name="usageEndDate"> DateTime in ISO8601 format. Default = current date. </param>
        /// <param name="offerId"> OfferId. </param>
        /// <param name="planId"> PlanId. </param>
        /// <param name="dimension"> DimensionId. </param>
        /// <param name="azureSubscriptionId"> Azure Subscription Id. </param>
        /// <param name="reconStatus"> Recon Status. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<GetUsageEventOkResponse>> GetUsageEventAsync(DateTimeOffset usageStartDate, DateTimeOffset? usageEndDate = null, string offerId = null, string planId = null, string dimension = null, Guid? azureSubscriptionId = null, ReconStatusEnum? reconStatus = null, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.GetUsageEvent");
            scope.Start();
            try
            {
                return await RestClient.GetUsageEventAsync(usageStartDate, usageEndDate, offerId, planId, dimension, azureSubscriptionId, reconStatus, requestId, correlationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can call the usage events API to get the list of usage events. </summary>
        /// <param name="usageStartDate"> DateTime in ISO8601 format. For example, 2020-12-03T15:00 or 2020-12-03. </param>
        /// <param name="usageEndDate"> DateTime in ISO8601 format. Default = current date. </param>
        /// <param name="offerId"> OfferId. </param>
        /// <param name="planId"> PlanId. </param>
        /// <param name="dimension"> DimensionId. </param>
        /// <param name="azureSubscriptionId"> Azure Subscription Id. </param>
        /// <param name="reconStatus"> Recon Status. </param>
        /// <param name="requestId"> A unique string value for tracking the request from the client, preferably a GUID. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="correlationId"> A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this value isn&apos;t provided, one will be generated and provided in the response headers. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<GetUsageEventOkResponse> GetUsageEvent(DateTimeOffset usageStartDate, DateTimeOffset? usageEndDate = null, string offerId = null, string planId = null, string dimension = null, Guid? azureSubscriptionId = null, ReconStatusEnum? reconStatus = null, Guid? requestId = null, Guid? correlationId = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("MeteringOperations.GetUsageEvent");
            scope.Start();
            try
            {
                return RestClient.GetUsageEvent(usageStartDate, usageEndDate, offerId, planId, dimension, azureSubscriptionId, reconStatus, requestId, correlationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
